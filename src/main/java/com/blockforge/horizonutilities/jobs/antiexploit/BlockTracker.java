package com.blockforge.horizonutilities.jobs.antiexploit;

import com.blockforge.horizonutilities.HorizonUtilitiesPlugin;
import org.bukkit.NamespacedKey;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.persistence.PersistentDataContainer;
import org.bukkit.persistence.PersistentDataType;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.UUID;
import java.util.logging.Level;

/**
 * Tracks player-placed blocks to prevent break-and-replace farming.
 * <p>
 * Uses Paper's PersistentDataContainer API when available (detected via
 * class lookup); falls back to an SQLite table on vanilla Spigot.
 */
public class BlockTracker {

    private static final String PDC_KEY_NAME = "placed_by";
    private static final boolean PAPER_AVAILABLE;

    static {
        boolean paper;
        try {
            Class.forName("io.papermc.paper.persistence.PersistentDataContainerView");
            paper = true;
        } catch (ClassNotFoundException e) {
            paper = false;
        }
        PAPER_AVAILABLE = paper;
    }

    private final HorizonUtilitiesPlugin plugin;
    private final NamespacedKey placedByKey;

    public BlockTracker(HorizonUtilitiesPlugin plugin) {
        this.plugin = plugin;
        this.placedByKey = new NamespacedKey(plugin, PDC_KEY_NAME);
    }

    // -------------------------------------------------------------------------
    // Public API
    // -------------------------------------------------------------------------

    /**
     * Marks {@code block} as placed by {@code placer}. Future break events for
     * this block will return {@code true} from {@link #isPlayerPlaced}.
     */
    public void markAsPlaced(Block block, UUID placer) {
        if (PAPER_AVAILABLE) {
            pdcMark(block, placer);
        } else {
            dbMark(block, placer);
        }
    }

    /**
     * Returns {@code true} if this block was placed by a player (and therefore
     * should not pay job income when broken).
     */
    public boolean isPlayerPlaced(Block block) {
        if (PAPER_AVAILABLE) {
            return pdcCheck(block);
        } else {
            return dbCheck(block);
        }
    }

    /**
     * Removes the placed-by tag when a block is broken. Call this from
     * BlockBreakEvent AFTER the income check so the tag is still present during
     * the check.
     */
    public void clearBlock(Block block) {
        if (PAPER_AVAILABLE) {
            pdcClear(block);
        } else {
            dbClear(block);
        }
    }

    /**
     * Transfers placed-by tags when a piston moves blocks so tags don't become
     * orphaned at wrong coordinates.
     *
     * @param movedBlocks list of blocks being moved (pre-move positions)
     * @param direction   piston push direction
     */
    public void handlePistonMove(List<Block> movedBlocks, BlockFace direction) {
        // When using PDC on block TileEntities / chunk data this is handled
        // automatically by the server. For the SQLite fallback we need to
        // update coordinates.
        if (!PAPER_AVAILABLE) {
            for (Block block : movedBlocks) {
                Block dest = block.getRelative(direction);
                if (dbCheck(block)) {
                    String placer = dbGetPlacer(block);
                    dbClear(block);
                    if (placer != null) {
                        try {
                            dbMarkRaw(dest, placer);
                        } catch (SQLException e) {
                            plugin.getLogger().log(Level.WARNING,
                                    "[BlockTracker] Failed to transfer piston block tag", e);
                        }
                    }
                }
            }
        }
        // Paper: PDC follows the block automatically when moved by pistons.
    }

    // -------------------------------------------------------------------------
    // PDC implementation (Paper)
    // -------------------------------------------------------------------------

    private void pdcMark(Block block, UUID placer) {
        try {
            if (block.getState() instanceof org.bukkit.block.TileState ts) {
                PersistentDataContainer pdc = ts.getPersistentDataContainer();
                pdc.set(placedByKey, PersistentDataType.STRING, placer.toString());
                ts.update();
            }
            // For non-tile blocks we store in the chunk's pdc using a compound key.
            else {
                String chunkKey = chunkKey(block);
                PersistentDataContainer chunkPdc = block.getChunk().getPersistentDataContainer();
                chunkPdc.set(new NamespacedKey(plugin, chunkKey), PersistentDataType.STRING, placer.toString());
            }
        } catch (Exception e) {
            // Fall back silently to DB
            dbMark(block, placer);
        }
    }

    private boolean pdcCheck(Block block) {
        try {
            if (block.getState() instanceof org.bukkit.block.TileState ts) {
                return ts.getPersistentDataContainer().has(placedByKey, PersistentDataType.STRING);
            } else {
                String chunkKey = chunkKey(block);
                return block.getChunk().getPersistentDataContainer()
                        .has(new NamespacedKey(plugin, chunkKey), PersistentDataType.STRING);
            }
        } catch (Exception e) {
            return dbCheck(block);
        }
    }

    private void pdcClear(Block block) {
        try {
            if (block.getState() instanceof org.bukkit.block.TileState ts) {
                ts.getPersistentDataContainer().remove(placedByKey);
                ts.update();
            } else {
                String chunkKey = chunkKey(block);
                block.getChunk().getPersistentDataContainer()
                        .remove(new NamespacedKey(plugin, chunkKey));
            }
        } catch (Exception e) {
            dbClear(block);
        }
    }

    // -------------------------------------------------------------------------
    // SQLite fallback implementation
    // -------------------------------------------------------------------------

    private void dbMark(Block block, UUID placer) {
        try {
            dbMarkRaw(block, placer.toString());
        } catch (SQLException e) {
            plugin.getLogger().log(Level.WARNING, "[BlockTracker] Failed to mark block in DB", e);
        }
    }

    private void dbMarkRaw(Block block, String placerStr) throws SQLException {
        try (PreparedStatement ps = conn().prepareStatement(
                "INSERT OR REPLACE INTO jobs_placed_blocks (world, x, y, z, player_uuid, placed_at) " +
                "VALUES (?, ?, ?, ?, ?, ?)")) {
            ps.setString(1, block.getWorld().getName());
            ps.setInt(2, block.getX());
            ps.setInt(3, block.getY());
            ps.setInt(4, block.getZ());
            ps.setString(5, placerStr);
            ps.setLong(6, System.currentTimeMillis());
            ps.executeUpdate();
        }
    }

    private boolean dbCheck(Block block) {
        try (PreparedStatement ps = conn().prepareStatement(
                "SELECT 1 FROM jobs_placed_blocks WHERE world=? AND x=? AND y=? AND z=?")) {
            ps.setString(1, block.getWorld().getName());
            ps.setInt(2, block.getX());
            ps.setInt(3, block.getY());
            ps.setInt(4, block.getZ());
            ResultSet rs = ps.executeQuery();
            return rs.next();
        } catch (SQLException e) {
            return false;
        }
    }

    private String dbGetPlacer(Block block) {
        try (PreparedStatement ps = conn().prepareStatement(
                "SELECT player_uuid FROM jobs_placed_blocks WHERE world=? AND x=? AND y=? AND z=?")) {
            ps.setString(1, block.getWorld().getName());
            ps.setInt(2, block.getX());
            ps.setInt(3, block.getY());
            ps.setInt(4, block.getZ());
            ResultSet rs = ps.executeQuery();
            return rs.next() ? rs.getString("player_uuid") : null;
        } catch (SQLException e) {
            return null;
        }
    }

    private void dbClear(Block block) {
        try (PreparedStatement ps = conn().prepareStatement(
                "DELETE FROM jobs_placed_blocks WHERE world=? AND x=? AND y=? AND z=?")) {
            ps.setString(1, block.getWorld().getName());
            ps.setInt(2, block.getX());
            ps.setInt(3, block.getY());
            ps.setInt(4, block.getZ());
            ps.executeUpdate();
        } catch (SQLException e) {
            plugin.getLogger().log(Level.WARNING, "[BlockTracker] Failed to clear block in DB", e);
        }
    }

    // -------------------------------------------------------------------------
    // Helpers
    // -------------------------------------------------------------------------

    /** Generates a unique key for a non-tile block within its chunk's PDC. */
    private String chunkKey(Block block) {
        int lx = block.getX() & 0xF;
        int lz = block.getZ() & 0xF;
        return "pb_" + lx + "_" + block.getY() + "_" + lz;
    }

    private Connection conn() {
        return plugin.getDatabaseManager().getConnection();
    }
}
