package com.blockforge.horizonutilities.jobs.antiexploit;

import com.blockforge.horizonutilities.jobs.JobAction;
import org.bukkit.Location;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Detects area-farming exploits by tracking a sliding window of recent actions
 * per player. If a player performs too many actions of the same type within a
 * given radius and timeframe, the action is flagged as an exploit.
 */
public class AreaFarmingDetector {

    // -------------------------------------------------------------------------
    // Inner record
    // -------------------------------------------------------------------------

    public static class ActionRecord {
        final Location loc;
        final long timestamp;
        final JobAction action;

        ActionRecord(Location loc, long timestamp, JobAction action) {
            this.loc = loc;
            this.timestamp = timestamp;
            this.action = action;
        }
    }

    // -------------------------------------------------------------------------
    // State
    // -------------------------------------------------------------------------

    private static final int MAX_DEQUE_SIZE = 500;

    /** playerUuid -> recent action records */
    private final Map<UUID, Deque<ActionRecord>> recentActions = new ConcurrentHashMap<>();

    // Default thresholds (can be overridden via constructor)
    private final int maxActionsInRadius;
    private final int radius;
    private final long timeframeMs;

    public AreaFarmingDetector(int maxActionsInRadius, int radius, long timeframeMs) {
        this.maxActionsInRadius = maxActionsInRadius;
        this.radius = radius;
        this.timeframeMs = timeframeMs;
    }

    // -------------------------------------------------------------------------
    // Public API
    // -------------------------------------------------------------------------

    /**
     * Records a new action for the player. Should be called on every paid
     * action BEFORE checking {@link #isExploiting}.
     */
    public void recordAction(UUID playerUuid, Location loc, JobAction action) {
        Deque<ActionRecord> deque = recentActions.computeIfAbsent(playerUuid, k -> new ArrayDeque<>());
        synchronized (deque) {
            deque.addLast(new ActionRecord(loc.clone(), System.currentTimeMillis(), action));
            // Keep deque bounded
            while (deque.size() > MAX_DEQUE_SIZE) {
                deque.pollFirst();
            }
        }
    }

    /**
     * Returns how many recent actions of the same type the player has performed
     * within {@code radius} blocks of {@code center} in the last
     * {@code timeframeMs} milliseconds.
     */
    public int getRecentActionsInRadius(UUID playerUuid, Location center, int radius, long timeframeMs) {
        Deque<ActionRecord> deque = recentActions.get(playerUuid);
        if (deque == null) return 0;

        long cutoff = System.currentTimeMillis() - timeframeMs;
        double radiusSq = radius * radius;
        int count = 0;

        synchronized (deque) {
            for (ActionRecord record : deque) {
                if (record.timestamp < cutoff) continue;
                if (!record.loc.getWorld().equals(center.getWorld())) continue;
                if (record.loc.distanceSquared(center) <= radiusSq) {
                    count++;
                }
            }
        }
        return count;
    }

    /**
     * Returns {@code true} if this action should be blocked as an exploit.
     * Uses the detector's configured radius, timeframe, and threshold.
     */
    public boolean isExploiting(UUID playerUuid, Location loc, JobAction action) {
        int count = getRecentActionsInRadius(playerUuid, loc, radius, timeframeMs);
        return count >= maxActionsInRadius;
    }

    /**
     * Purges action records older than {@code timeframeMs} from all deques.
     * Call this periodically (e.g. every 30 seconds) to prevent memory growth.
     */
    public void cleanup() {
        long cutoff = System.currentTimeMillis() - timeframeMs;
        for (Map.Entry<UUID, Deque<ActionRecord>> entry : recentActions.entrySet()) {
            Deque<ActionRecord> deque = entry.getValue();
            synchronized (deque) {
                while (!deque.isEmpty() && deque.peekFirst().timestamp < cutoff) {
                    deque.pollFirst();
                }
            }
        }
        // Remove empty deques
        recentActions.entrySet().removeIf(e -> {
            synchronized (e.getValue()) { return e.getValue().isEmpty(); }
        });
    }

    /** Clears all records for a player (call on logout). */
    public void clearPlayer(UUID playerUuid) {
        recentActions.remove(playerUuid);
    }
}
